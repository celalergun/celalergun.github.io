{
  "version": 3,
  "sources": ["index.ts", "indexdb.ts"],
  "sourcesContent": ["/**\n * Human demo for browsers\n * @default Human Library\n * @summary <https://github.com/vladmandic/human>\n * @author <https://github.com/vladmandic>\n * @copyright <https://github.com/vladmandic>\n * @license MIT\n */\n\nimport { Human, TensorLike, FaceResult } from '../../dist/human.esm.js'; // equivalent of @vladmandic/Human\nimport * as indexDb from './indexdb'; // methods to deal with indexdb\n\nconst humanConfig = { // user configuration for human, used to fine-tune behavior\n  modelBasePath: '../../models',\n  filter: { equalization: true }, // lets run with histogram equilizer\n  face: {\n    enabled: true,\n    detector: { rotation: true, return: true, cropFactor: 1.6, mask: false }, // return tensor is used to get detected face image\n    description: { enabled: true }, // default model for face descriptor extraction is faceres\n    mobilefacenet: { enabled: false, modelPath: 'https://vladmandic.github.io/human-models/models/mobilefacenet.json' }, // alternative model\n    iris: { enabled: true }, // needed to determine gaze direction\n    emotion: { enabled: false }, // not needed\n    antispoof: { enabled: true }, // enable optional antispoof module\n    liveness: { enabled: true }, // enable optional liveness module\n  },\n  body: { enabled: false },\n  hand: { enabled: false },\n  object: { enabled: false },\n  gesture: { enabled: true }, // parses face and iris gestures\n};\n\n// const matchOptions = { order: 2, multiplier: 1000, min: 0.0, max: 1.0 }; // for embedding model\nconst matchOptions = { order: 2, multiplier: 25, min: 0.2, max: 0.8 }; // for faceres model\n\nconst options = {\n  minConfidence: 0.6, // overal face confidence for box, face, gender, real, live\n  minSize: 224, // min input to face descriptor model before degradation\n  maxTime: 10000, // max time before giving up\n  blinkMin: 10, // minimum duration of a valid blink\n  blinkMax: 800, // maximum duration of a valid blink\n  threshold: 0.5, // minimum similarity\n  mask: humanConfig.face.detector.mask,\n  rotation: humanConfig.face.detector.rotation,\n  cropFactor: humanConfig.face.detector.cropFactor,\n  ...matchOptions,\n};\n\nconst ok = { // must meet all rules\n  faceCount: false,\n  faceConfidence: false,\n  facingCenter: false,\n  lookingCenter: false,\n  blinkDetected: false,\n  faceSize: false,\n  antispoofCheck: false,\n  livenessCheck: false,\n  elapsedMs: 0, // total time while waiting for valid face\n};\nconst allOk = () => ok.faceCount && ok.faceSize && ok.blinkDetected && ok.facingCenter && ok.lookingCenter && ok.faceConfidence && ok.antispoofCheck && ok.livenessCheck;\nconst current: { face: FaceResult | null, record: indexDb.FaceRecord | null } = { face: null, record: null }; // current face record and matched database record\n\nconst blink = { // internal timers for blink start/end/duration\n  start: 0,\n  end: 0,\n  time: 0,\n};\n\n// let db: Array<{ name: string, source: string, embedding: number[] }> = []; // holds loaded face descriptor database\nconst human = new Human(humanConfig); // create instance of human with overrides from user configuration\n\nhuman.env['perfadd'] = false; // is performance data showing instant or total values\nhuman.draw.options.font = 'small-caps 18px \"Lato\"'; // set font used to draw labels when using draw methods\nhuman.draw.options.lineHeight = 20;\n\nconst dom = { // grab instances of dom objects so we dont have to look them up later\n  video: document.getElementById('video') as HTMLVideoElement,\n  canvas: document.getElementById('canvas') as HTMLCanvasElement,\n  log: document.getElementById('log') as HTMLPreElement,\n  fps: document.getElementById('fps') as HTMLPreElement,\n  match: document.getElementById('match') as HTMLDivElement,\n  name: document.getElementById('name') as HTMLInputElement,\n  save: document.getElementById('save') as HTMLSpanElement,\n  delete: document.getElementById('delete') as HTMLSpanElement,\n  retry: document.getElementById('retry') as HTMLDivElement,\n  source: document.getElementById('source') as HTMLCanvasElement,\n  ok: document.getElementById('ok') as HTMLDivElement,\n};\nconst timestamp = { detect: 0, draw: 0 }; // holds information used to calculate performance and possible memory leaks\nconst fps = { detect: 0, draw: 0 }; // holds calculated fps information for both detect and screen refresh\nlet startTime = 0;\n\nconst log = (...msg) => { // helper method to output messages\n  dom.log.innerText += msg.join(' ') + '\\n';\n  // eslint-disable-next-line no-console\n  console.log(...msg);\n};\nconst printFPS = (msg) => dom.fps.innerText = msg; // print status element\n\nasync function webCam() { // initialize webcam\n  printFPS('starting webcam...');\n  // @ts-ignore resizeMode is not yet defined in tslib\n  const cameraOptions: MediaStreamConstraints = { audio: false, video: { facingMode: 'user', resizeMode: 'none', width: { ideal: document.body.clientWidth } } };\n  const stream: MediaStream = await navigator.mediaDevices.getUserMedia(cameraOptions);\n  const ready = new Promise((resolve) => { dom.video.onloadeddata = () => resolve(true); });\n  dom.video.srcObject = stream;\n  dom.video.play();\n  await ready;\n  dom.canvas.width = dom.video.videoWidth;\n  dom.canvas.height = dom.video.videoHeight;\n  if (human.env.initial) log('video:', dom.video.videoWidth, dom.video.videoHeight, '|', stream.getVideoTracks()[0].label);\n  dom.canvas.onclick = () => { // pause when clicked on screen and resume on next click\n    if (dom.video.paused) dom.video.play();\n    else dom.video.pause();\n  };\n}\n\nasync function detectionLoop() { // main detection loop\n  if (!dom.video.paused) {\n    if (current.face && current.face.tensor) human.tf.dispose(current.face.tensor); // dispose previous tensor\n    await human.detect(dom.video); // actual detection; were not capturing output in a local variable as it can also be reached via human.result\n    const now = human.now();\n    fps.detect = 1000 / (now - timestamp.detect);\n    timestamp.detect = now;\n    requestAnimationFrame(detectionLoop); // start new frame immediately\n  }\n}\n\nasync function validationLoop(): Promise<FaceResult> { // main screen refresh loop\n  const interpolated = await human.next(human.result); // smoothen result using last-known results\n  await human.draw.canvas(dom.video, dom.canvas); // draw canvas to screen\n  await human.draw.all(dom.canvas, interpolated); // draw labels, boxes, lines, etc.\n  const now = human.now();\n  fps.draw = 1000 / (now - timestamp.draw);\n  timestamp.draw = now;\n  printFPS(`fps: ${fps.detect.toFixed(1).padStart(5, ' ')} detect | ${fps.draw.toFixed(1).padStart(5, ' ')} draw`); // write status\n  ok.faceCount = human.result.face.length === 1; // must be exactly detected face\n  if (ok.faceCount) { // skip the rest if no face\n    const gestures: string[] = Object.values(human.result.gesture).map((gesture) => gesture.gesture); // flatten all gestures\n    if (gestures.includes('blink left eye') || gestures.includes('blink right eye')) blink.start = human.now(); // blink starts when eyes get closed\n    if (blink.start > 0 && !gestures.includes('blink left eye') && !gestures.includes('blink right eye')) blink.end = human.now(); // if blink started how long until eyes are back open\n    ok.blinkDetected = ok.blinkDetected || (Math.abs(blink.end - blink.start) > options.blinkMin && Math.abs(blink.end - blink.start) < options.blinkMax);\n    if (ok.blinkDetected && blink.time === 0) blink.time = Math.trunc(blink.end - blink.start);\n    ok.facingCenter = gestures.includes('facing center');\n    ok.lookingCenter = gestures.includes('looking center'); // must face camera and look at camera\n    ok.faceConfidence = (human.result.face[0].boxScore || 0) > options.minConfidence && (human.result.face[0].faceScore || 0) > options.minConfidence && (human.result.face[0].genderScore || 0) > options.minConfidence;\n    ok.antispoofCheck = (human.result.face[0].real || 0) > options.minConfidence;\n    ok.livenessCheck = (human.result.face[0].live || 0) > options.minConfidence;\n    ok.faceSize = human.result.face[0].box[2] >= options.minSize && human.result.face[0].box[3] >= options.minSize;\n  }\n  let y = 32;\n  for (const [key, val] of Object.entries(ok)) {\n    let el = document.getElementById(`ok-${key}`);\n    if (!el) {\n      el = document.createElement('div');\n      el.innerText = key;\n      el.className = 'ok';\n      el.style.top = `${y}px`;\n      dom.ok.appendChild(el);\n    }\n    if (typeof val === 'boolean') el.style.backgroundColor = val ? 'lightgreen' : 'lightcoral';\n    else el.innerText = `${key}:${val}`;\n    y += 28;\n  }\n  if (allOk()) { // all criteria met\n    dom.video.pause();\n    return human.result.face[0];\n  }\n  if (ok.elapsedMs > options.maxTime) { // give up\n    dom.video.pause();\n    return human.result.face[0];\n  } else { // run again\n    ok.elapsedMs = Math.trunc(human.now() - startTime);\n    return new Promise((resolve) => {\n      setTimeout(async () => {\n        const res = await validationLoop(); // run validation loop until conditions are met\n        if (res) resolve(human.result.face[0]); // recursive promise resolve\n      }, 30); // use to slow down refresh from max refresh rate to target of 30 fps\n    });\n  }\n}\n\nasync function saveRecords() {\n  if (dom.name.value.length > 0) {\n    const image = dom.canvas.getContext('2d')?.getImageData(0, 0, dom.canvas.width, dom.canvas.height) as ImageData;\n    const rec = { id: 0, name: dom.name.value, descriptor: current.face?.embedding as number[], image };\n    await indexDb.save(rec);\n    log('saved face record:', rec.name);\n  } else {\n    log('invalid name');\n  }\n}\n\nasync function deleteRecord() {\n  if (current.record && current.record.id > 0) {\n    await indexDb.remove(current.record);\n  }\n}\n\nasync function detectFace() {\n  dom.canvas.getContext('2d')?.clearRect(0, 0, options.minSize, options.minSize);\n  if (!current.face || !current.face.tensor || !current.face.embedding) return false;\n  // eslint-disable-next-line no-console\n  console.log('face record:', current.face);\n  human.tf.browser.toPixels(current.face.tensor as unknown as TensorLike, dom.canvas);\n  if (await indexDb.count() === 0) {\n    log('face database is empty');\n    document.body.style.background = 'black';\n    dom.delete.style.display = 'none';\n    return false;\n  }\n  const db = await indexDb.load();\n  const descriptors = db.map((rec) => rec.descriptor);\n  const res = await human.match(current.face.embedding, descriptors, matchOptions);\n  current.record = db[res.index] || null;\n  if (current.record) {\n    log(`best match: ${current.record.name} | id: ${current.record.id} | similarity: ${Math.round(1000 * res.similarity) / 10}%`);\n    dom.name.value = current.record.name;\n    dom.source.style.display = '';\n    dom.source.getContext('2d')?.putImageData(current.record.image, 0, 0);\n  }\n  document.body.style.background = res.similarity > options.threshold ? 'darkgreen' : 'maroon';\n  return res.similarity > options.threshold;\n}\n\nasync function main() { // main entry point\n  ok.faceCount = false;\n  ok.faceConfidence = false;\n  ok.facingCenter = false;\n  ok.blinkDetected = false;\n  ok.faceSize = false;\n  ok.antispoofCheck = false;\n  ok.livenessCheck = false;\n  ok.elapsedMs = 0;\n  dom.match.style.display = 'none';\n  dom.retry.style.display = 'none';\n  dom.source.style.display = 'none';\n  document.body.style.background = 'black';\n  await webCam();\n  await detectionLoop(); // start detection loop\n  startTime = human.now();\n  current.face = await validationLoop(); // start validation loop\n  dom.canvas.width = current.face?.tensor?.shape[1] || options.minSize;\n  dom.canvas.height = current.face?.tensor?.shape[0] || options.minSize;\n  dom.source.width = dom.canvas.width;\n  dom.source.height = dom.canvas.height;\n  dom.canvas.style.width = '';\n  dom.match.style.display = 'flex';\n  dom.save.style.display = 'flex';\n  dom.delete.style.display = 'flex';\n  dom.retry.style.display = 'block';\n  if (!allOk()) { // is all criteria met?\n    log('did not find valid face');\n    return false;\n  } else {\n    return detectFace();\n  }\n}\n\nasync function init() {\n  log('human version:', human.version, '| tfjs version:', human.tf.version['tfjs-core']);\n  log('options:', JSON.stringify(options).replace(/{|}|\"|\\[|\\]/g, '').replace(/,/g, ' '));\n  printFPS('loading...');\n  log('known face records:', await indexDb.count());\n  await webCam(); // start webcam\n  await human.load(); // preload all models\n  printFPS('initializing...');\n  dom.retry.addEventListener('click', main);\n  dom.save.addEventListener('click', saveRecords);\n  dom.delete.addEventListener('click', deleteRecord);\n  await human.warmup(); // warmup function to initialize backend for future faster detection\n  await main();\n}\n\nwindow.onload = init;\n", "let db: IDBDatabase; // instance of indexdb\n\nconst database = 'human';\nconst table = 'person';\n\nexport type FaceRecord = { id: number, name: string, descriptor: number[], image: ImageData };\n\n// eslint-disable-next-line no-console\nconst log = (...msg) => console.log('indexdb', ...msg);\n\nexport async function open() {\n  if (db) return true;\n  return new Promise((resolve) => {\n    const request: IDBOpenDBRequest = indexedDB.open(database, 1);\n    request.onerror = (evt) => log('error:', evt);\n    request.onupgradeneeded = (evt: IDBVersionChangeEvent) => { // create if doesnt exist\n      log('create:', evt.target);\n      db = (evt.target as IDBOpenDBRequest).result;\n      db.createObjectStore(table, { keyPath: 'id', autoIncrement: true });\n    };\n    request.onsuccess = (evt) => { // open\n      db = (evt.target as IDBOpenDBRequest).result as IDBDatabase;\n      log('open:', db);\n      resolve(true);\n    };\n  });\n}\n\nexport async function load(): Promise<FaceRecord[]> {\n  const faceDB: Array<FaceRecord> = [];\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const cursor: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).openCursor(null, 'next');\n    cursor.onerror = (evt) => log('load error:', evt);\n    cursor.onsuccess = (evt) => {\n      if ((evt.target as IDBRequest).result) {\n        faceDB.push((evt.target as IDBRequest).result.value);\n        (evt.target as IDBRequest).result.continue();\n      } else {\n        resolve(faceDB);\n      }\n    };\n  });\n}\n\nexport async function count(): Promise<number> {\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const store: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).count();\n    store.onerror = (evt) => log('count error:', evt);\n    store.onsuccess = () => resolve(store.result);\n  });\n}\n\nexport async function save(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  const newRecord = { name: faceRecord.name, descriptor: faceRecord.descriptor, image: faceRecord.image }; // omit id as its autoincrement\n  db.transaction([table], 'readwrite').objectStore(table).put(newRecord);\n  log('save:', newRecord);\n}\n\nexport async function remove(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  db.transaction([table], 'readwrite').objectStore(table).delete(faceRecord.id); // delete based on id\n  log('delete:', faceRecord);\n}\n"],
  "mappings": ";;;;;;AASA,gDCTA,GAAI,GAEE,EAAW,QACX,EAAQ,SAKR,EAAM,IAAI,IAAQ,QAAQ,IAAI,UAAW,GAAG,GAElD,kBAA6B,CAC3B,MAAI,GAAW,GACR,GAAI,SAAQ,AAAC,GAAY,CAC9B,GAAM,GAA4B,UAAU,KAAK,EAAU,GAC3D,EAAQ,QAAU,AAAC,GAAQ,EAAI,SAAU,GACzC,EAAQ,gBAAkB,AAAC,GAA+B,CACxD,EAAI,UAAW,EAAI,QACnB,EAAM,EAAI,OAA4B,OACtC,EAAG,kBAAkB,EAAO,CAAE,QAAS,KAAM,cAAe,MAE9D,EAAQ,UAAY,AAAC,GAAQ,CAC3B,EAAM,EAAI,OAA4B,OACtC,EAAI,QAAS,GACb,EAAQ,OAKd,kBAAoD,CAClD,GAAM,GAA4B,GAClC,MAAK,IAAI,KAAM,KACR,GAAI,SAAQ,AAAC,GAAY,CAC9B,GAAM,GAAqB,EAAG,YAAY,CAAC,GAAQ,aAAa,YAAY,GAAO,WAAW,KAAM,QACpG,EAAO,QAAU,AAAC,GAAQ,EAAI,cAAe,GAC7C,EAAO,UAAY,AAAC,GAAQ,CAC1B,AAAK,EAAI,OAAsB,OAC7B,GAAO,KAAM,EAAI,OAAsB,OAAO,OAC7C,EAAI,OAAsB,OAAO,YAElC,EAAQ,MAMhB,kBAA+C,CAC7C,MAAK,IAAI,KAAM,KACR,GAAI,SAAQ,AAAC,GAAY,CAC9B,GAAM,GAAoB,EAAG,YAAY,CAAC,GAAQ,aAAa,YAAY,GAAO,QAClF,EAAM,QAAU,AAAC,GAAQ,EAAI,eAAgB,GAC7C,EAAM,UAAY,IAAM,EAAQ,EAAM,UAI1C,iBAA2B,EAAwB,CACjD,AAAK,GAAI,KAAM,KACf,GAAM,GAAY,CAAE,KAAM,EAAW,KAAM,WAAY,EAAW,WAAY,MAAO,EAAW,OAChG,EAAG,YAAY,CAAC,GAAQ,aAAa,YAAY,GAAO,IAAI,GAC5D,EAAI,QAAS,GAGf,iBAA6B,EAAwB,CACnD,AAAK,GAAI,KAAM,KACf,EAAG,YAAY,CAAC,GAAQ,aAAa,YAAY,GAAO,OAAO,EAAW,IAC1E,EAAI,UAAW,GDhEjB,AAYA,GAAM,GAAc,CAClB,cAAe,eACf,OAAQ,CAAE,aAAc,IACxB,KAAM,CACJ,QAAS,GACT,SAAU,CAAE,SAAU,GAAM,OAAQ,GAAM,WAAY,IAAK,KAAM,IACjE,YAAa,CAAE,QAAS,IACxB,cAAe,CAAE,QAAS,GAAO,UAAW,uEAC5C,KAAM,CAAE,QAAS,IACjB,QAAS,CAAE,QAAS,IACpB,UAAW,CAAE,QAAS,IACtB,SAAU,CAAE,QAAS,KAEvB,KAAM,CAAE,QAAS,IACjB,KAAM,CAAE,QAAS,IACjB,OAAQ,CAAE,QAAS,IACnB,QAAS,CAAE,QAAS,KAIhB,EAAe,CAAE,MAAO,EAAG,WAAY,GAAI,IAAK,GAAK,IAAK,IAE1D,EAAU,CACd,cAAe,GACf,QAAS,IACT,QAAS,IACT,SAAU,GACV,SAAU,IACV,UAAW,GACX,KAAM,EAAY,KAAK,SAAS,KAChC,SAAU,EAAY,KAAK,SAAS,SACpC,WAAY,EAAY,KAAK,SAAS,cACnC,GAGC,EAAK,CACT,UAAW,GACX,eAAgB,GAChB,aAAc,GACd,cAAe,GACf,cAAe,GACf,SAAU,GACV,eAAgB,GAChB,cAAe,GACf,UAAW,GAEP,EAAQ,IAAM,EAAG,WAAa,EAAG,UAAY,EAAG,eAAiB,EAAG,cAAgB,EAAG,eAAiB,EAAG,gBAAkB,EAAG,gBAAkB,EAAG,cACrJ,EAA0E,CAAE,KAAM,KAAM,OAAQ,MAEhG,EAAQ,CACZ,MAAO,EACP,IAAK,EACL,KAAM,GAIF,EAAQ,GAAI,GAAM,GAExB,EAAM,IAAI,QAAa,GACvB,EAAM,KAAK,QAAQ,KAAO,yBAC1B,EAAM,KAAK,QAAQ,WAAa,GAEhC,GAAM,GAAM,CACV,MAAO,SAAS,eAAe,SAC/B,OAAQ,SAAS,eAAe,UAChC,IAAK,SAAS,eAAe,OAC7B,IAAK,SAAS,eAAe,OAC7B,MAAO,SAAS,eAAe,SAC/B,KAAM,SAAS,eAAe,QAC9B,KAAM,SAAS,eAAe,QAC9B,OAAQ,SAAS,eAAe,UAChC,MAAO,SAAS,eAAe,SAC/B,OAAQ,SAAS,eAAe,UAChC,GAAI,SAAS,eAAe,OAExB,EAAY,CAAE,OAAQ,EAAG,KAAM,GAC/B,EAAM,CAAE,OAAQ,EAAG,KAAM,GAC3B,EAAY,EAEV,EAAM,IAAI,IAAQ,CACtB,EAAI,IAAI,WAAa,EAAI,KAAK,KAAO;AAAA,EAErC,QAAQ,IAAI,GAAG,IAEX,EAAW,AAAC,GAAQ,EAAI,IAAI,UAAY,EAE9C,kBAAwB,CACtB,EAAS,sBAET,GAAM,GAAwC,CAAE,MAAO,GAAO,MAAO,CAAE,WAAY,OAAQ,WAAY,OAAQ,MAAO,CAAE,MAAO,SAAS,KAAK,eACvI,EAAsB,KAAM,WAAU,aAAa,aAAa,GAChE,EAAQ,GAAI,SAAQ,AAAC,GAAY,CAAE,EAAI,MAAM,aAAe,IAAM,EAAQ,MAChF,EAAI,MAAM,UAAY,EACtB,EAAI,MAAM,OACV,KAAM,GACN,EAAI,OAAO,MAAQ,EAAI,MAAM,WAC7B,EAAI,OAAO,OAAS,EAAI,MAAM,YAC1B,EAAM,IAAI,SAAS,EAAI,SAAU,EAAI,MAAM,WAAY,EAAI,MAAM,YAAa,IAAK,EAAO,iBAAiB,GAAG,OAClH,EAAI,OAAO,QAAU,IAAM,CACzB,AAAI,EAAI,MAAM,OAAQ,EAAI,MAAM,OAC3B,EAAI,MAAM,SAInB,kBAA+B,CAC7B,GAAI,CAAC,EAAI,MAAM,OAAQ,CACrB,AAAI,EAAQ,MAAQ,EAAQ,KAAK,QAAQ,EAAM,GAAG,QAAQ,EAAQ,KAAK,QACvE,KAAM,GAAM,OAAO,EAAI,OACvB,GAAM,GAAM,EAAM,MAClB,EAAI,OAAS,IAAQ,GAAM,EAAU,QACrC,EAAU,OAAS,EACnB,sBAAsB,IAI1B,kBAAqD,CACnD,GAAM,GAAe,KAAM,GAAM,KAAK,EAAM,QAC5C,KAAM,GAAM,KAAK,OAAO,EAAI,MAAO,EAAI,QACvC,KAAM,GAAM,KAAK,IAAI,EAAI,OAAQ,GACjC,GAAM,GAAM,EAAM,MAKlB,GAJA,EAAI,KAAO,IAAQ,GAAM,EAAU,MACnC,EAAU,KAAO,EACjB,EAAS,QAAQ,EAAI,OAAO,QAAQ,GAAG,SAAS,EAAG,iBAAiB,EAAI,KAAK,QAAQ,GAAG,SAAS,EAAG,aACpG,EAAG,UAAY,EAAM,OAAO,KAAK,SAAW,EACxC,EAAG,UAAW,CAChB,GAAM,GAAqB,OAAO,OAAO,EAAM,OAAO,SAAS,IAAI,AAAC,GAAY,EAAQ,SACxF,AAAI,GAAS,SAAS,mBAAqB,EAAS,SAAS,qBAAoB,GAAM,MAAQ,EAAM,OACjG,EAAM,MAAQ,GAAK,CAAC,EAAS,SAAS,mBAAqB,CAAC,EAAS,SAAS,oBAAoB,GAAM,IAAM,EAAM,OACxH,EAAG,cAAgB,EAAG,eAAkB,KAAK,IAAI,EAAM,IAAM,EAAM,OAAS,EAAQ,UAAY,KAAK,IAAI,EAAM,IAAM,EAAM,OAAS,EAAQ,SACxI,EAAG,eAAiB,EAAM,OAAS,GAAG,GAAM,KAAO,KAAK,MAAM,EAAM,IAAM,EAAM,QACpF,EAAG,aAAe,EAAS,SAAS,iBACpC,EAAG,cAAgB,EAAS,SAAS,kBACrC,EAAG,eAAkB,GAAM,OAAO,KAAK,GAAG,UAAY,GAAK,EAAQ,eAAkB,GAAM,OAAO,KAAK,GAAG,WAAa,GAAK,EAAQ,eAAkB,GAAM,OAAO,KAAK,GAAG,aAAe,GAAK,EAAQ,cACvM,EAAG,eAAkB,GAAM,OAAO,KAAK,GAAG,MAAQ,GAAK,EAAQ,cAC/D,EAAG,cAAiB,GAAM,OAAO,KAAK,GAAG,MAAQ,GAAK,EAAQ,cAC9D,EAAG,SAAW,EAAM,OAAO,KAAK,GAAG,IAAI,IAAM,EAAQ,SAAW,EAAM,OAAO,KAAK,GAAG,IAAI,IAAM,EAAQ,QAEzG,GAAI,GAAI,GACR,OAAW,CAAC,EAAK,IAAQ,QAAO,QAAQ,GAAK,CAC3C,GAAI,GAAK,SAAS,eAAe,MAAM,KACvC,AAAK,GACH,GAAK,SAAS,cAAc,OAC5B,EAAG,UAAY,EACf,EAAG,UAAY,KACf,EAAG,MAAM,IAAM,GAAG,MAClB,EAAI,GAAG,YAAY,IAErB,AAAI,MAAO,IAAQ,UAAW,EAAG,MAAM,gBAAkB,EAAM,aAAe,aACzE,EAAG,UAAY,GAAG,KAAO,IAC9B,GAAK,GAMP,MAJI,MAIA,EAAG,UAAY,EAAQ,QACzB,GAAI,MAAM,QACH,EAAM,OAAO,KAAK,IAEzB,GAAG,UAAY,KAAK,MAAM,EAAM,MAAQ,GACjC,GAAI,SAAQ,AAAC,GAAY,CAC9B,WAAW,SAAY,CAErB,AAAI,AADQ,KAAM,MACT,EAAQ,EAAM,OAAO,KAAK,KAClC,OAKT,kBAA6B,CArL7B,QAsLE,GAAI,EAAI,KAAK,MAAM,OAAS,EAAG,CAC7B,GAAM,GAAQ,KAAI,OAAO,WAAW,QAAtB,cAA6B,aAAa,EAAG,EAAG,EAAI,OAAO,MAAO,EAAI,OAAO,QACrF,EAAM,CAAE,GAAI,EAAG,KAAM,EAAI,KAAK,MAAO,WAAY,KAAQ,OAAR,cAAc,UAAuB,SAC5F,KAAM,AAAQ,GAAK,GACnB,EAAI,qBAAsB,EAAI,UAE9B,GAAI,gBAIR,kBAA8B,CAC5B,AAAI,EAAQ,QAAU,EAAQ,OAAO,GAAK,GACxC,KAAM,AAAQ,GAAO,EAAQ,QAIjC,kBAA4B,CAtM5B,QAwME,GADA,KAAI,OAAO,WAAW,QAAtB,QAA6B,UAAU,EAAG,EAAG,EAAQ,QAAS,EAAQ,SAClE,CAAC,EAAQ,MAAQ,CAAC,EAAQ,KAAK,QAAU,CAAC,EAAQ,KAAK,UAAW,MAAO,GAI7E,GAFA,QAAQ,IAAI,eAAgB,EAAQ,MACpC,EAAM,GAAG,QAAQ,SAAS,EAAQ,KAAK,OAAiC,EAAI,QACxE,KAAM,AAAQ,OAAY,EAC5B,SAAI,0BACJ,SAAS,KAAK,MAAM,WAAa,QACjC,EAAI,OAAO,MAAM,QAAU,OACpB,GAET,GAAM,GAAK,KAAM,AAAQ,KACnB,EAAc,EAAG,IAAI,AAAC,GAAQ,EAAI,YAClC,EAAM,KAAM,GAAM,MAAM,EAAQ,KAAK,UAAW,EAAa,GACnE,SAAQ,OAAS,EAAG,EAAI,QAAU,KAC9B,EAAQ,QACV,GAAI,eAAe,EAAQ,OAAO,cAAc,EAAQ,OAAO,oBAAoB,KAAK,MAAM,IAAO,EAAI,YAAc,OACvH,EAAI,KAAK,MAAQ,EAAQ,OAAO,KAChC,EAAI,OAAO,MAAM,QAAU,GAC3B,KAAI,OAAO,WAAW,QAAtB,QAA6B,aAAa,EAAQ,OAAO,MAAO,EAAG,IAErE,SAAS,KAAK,MAAM,WAAa,EAAI,WAAa,EAAQ,UAAY,YAAc,SAC7E,EAAI,WAAa,EAAQ,UAGlC,kBAAsB,CAhOtB,YA0PE,MAzBA,GAAG,UAAY,GACf,EAAG,eAAiB,GACpB,EAAG,aAAe,GAClB,EAAG,cAAgB,GACnB,EAAG,SAAW,GACd,EAAG,eAAiB,GACpB,EAAG,cAAgB,GACnB,EAAG,UAAY,EACf,EAAI,MAAM,MAAM,QAAU,OAC1B,EAAI,MAAM,MAAM,QAAU,OAC1B,EAAI,OAAO,MAAM,QAAU,OAC3B,SAAS,KAAK,MAAM,WAAa,QACjC,KAAM,KACN,KAAM,KACN,EAAY,EAAM,MAClB,EAAQ,KAAO,KAAM,KACrB,EAAI,OAAO,MAAQ,SAAQ,OAAR,cAAc,SAAd,cAAsB,MAAM,KAAM,EAAQ,QAC7D,EAAI,OAAO,OAAS,SAAQ,OAAR,cAAc,SAAd,cAAsB,MAAM,KAAM,EAAQ,QAC9D,EAAI,OAAO,MAAQ,EAAI,OAAO,MAC9B,EAAI,OAAO,OAAS,EAAI,OAAO,OAC/B,EAAI,OAAO,MAAM,MAAQ,GACzB,EAAI,MAAM,MAAM,QAAU,OAC1B,EAAI,KAAK,MAAM,QAAU,OACzB,EAAI,OAAO,MAAM,QAAU,OAC3B,EAAI,MAAM,MAAM,QAAU,QACrB,IAII,IAHP,GAAI,2BACG,IAMX,kBAAsB,CACpB,EAAI,iBAAkB,EAAM,QAAS,kBAAmB,EAAM,GAAG,QAAQ,cACzE,EAAI,WAAY,KAAK,UAAU,GAAS,QAAQ,eAAgB,IAAI,QAAQ,KAAM,MAClF,EAAS,cACT,EAAI,sBAAuB,KAAM,AAAQ,MACzC,KAAM,KACN,KAAM,GAAM,OACZ,EAAS,mBACT,EAAI,MAAM,iBAAiB,QAAS,GACpC,EAAI,KAAK,iBAAiB,QAAS,GACnC,EAAI,OAAO,iBAAiB,QAAS,GACrC,KAAM,GAAM,SACZ,KAAM,KAGR,OAAO,OAAS",
  "names": []
}
